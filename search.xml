<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[拉格朗日乘数法笔记]]></title>
    <url>%2F2017%2F03%2F22%2F2017-03-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在求解函数最优化问题中，拉格朗日乘子法（Lagrange Multiplier）和KKT（Karush Kuhn Tucker）条件是两种最常用的方法。函数有等式约束时使用拉格朗日乘子法，函数有不等约束时使用KKT条件。本文简要的复习下拉格朗日乘数法的浅层次问题。 拉格朗日乘数法 在求解函数最优化问题中，拉格朗日乘子法（Lagrange Multiplier）和KKT（Karush Kuhn Tucker）条件是两种最常用的方法。函数有等式约束时使用拉格朗日乘子法，函数有不等约束时使用KKT条件。 本篇文章主要整理拉格朗日乘子法这种方法可以将一个有 n 个变量与 k 个约束条件的最优化问题转换为一个解有 n + k 个变量的方程组的解的问题。这种方法中引入了一个或一组新的未知数，即拉格朗日乘数，又称拉格朗日乘子，或拉氏乘子，它们是在转换后的方程，即约束方程中作为梯度（gradient）的线性组合中各个向量的系数。 总结伸手党，比如两个变量求最优时，求 $f(x, y)$ 在条件 $ g(x,y)=c $ 时的最大值，我们可以引入新变量拉格朗日乘数 $ \lambda $，这时我们只需要下列拉格朗日函数的极值,此时就回归到了无约束时的最值问题： $$F(x,y,\lambda) = f(x,y)+\lambda \cdot(g(x,y)-c)$$ 无约束时函数最优问题这种问题，通常的解决办法是，对各变量求偏导，使得各偏导同时为零得到驻点。再判断驻点是否为极值点，最后代入原函数验证最优。 等式约束时函数最优问题设目标函数为 $f(x,y)$， 约束条件为 $g(x,y)=c$。问题是如何在满足约束条件的情况下，使得目标函数最大(最小)。 使用一个例子来描述这个问题：在双曲线 xy=3 的情况下，哪个点离原点最近。$$ f(x,y)=x^2+y^2 g(x,y)=xy=3 $$ 如图： 那么f(x,y) 可以被描述为无数个一圈圈的等高线(图中所有颜色的圆圈线)，这些等高线与双曲线相交的点是满足约束条件的点。那么离原点最近的点，就是等高线与双曲线互切处的点，如图中，红色的点。 绿色的等高线无法与双曲线相交，没有满足约束条件的解 蓝色点虽然满足约束条件，但并非最优解 只有等高线与双曲线相切的红色的点，才是最优解。 在取最优解时，我们发现只有相切才能取最优解。那么如何判断相切呢？ 那就使用梯度向量（如图中红色蓝色的梯度向量），如果两者梯度向量互相平行时，那么两条曲线相切。于是引入一个参数 $\lambda$ 使得满足如下梯度公式：$$\nabla f(x,y) = \lambda \cdot \nabla g(x, y)$$ 那么原目标函数 f(x,y) 和 约束条件 g(x,y) ，在取最优值时满足上述公式那么： $$\left\{\begin{aligned}f’_x = \lambda \cdot g’_x \\f’_y = \lambda \cdot g’_y \\\end{aligned}\right.\\g(x,y)=c$$ 此时我们就拥有了三个公式，三个未知数的多项式。把三个未知数全部解出来。代入原目标函数就是函数最值。 最后我们稍微整理下这三条公式: $$\left\{\begin{aligned}f’_x - \lambda \cdot g’_x = 0\\f’_y - \lambda \cdot g’_y = 0\\\end{aligned}\right.\\g(x,y)=c$$ 发现原最优问题可以被替换成求$F(x,y,\lambda) = f(x,y)+\lambda \cdot(g(x,y)-c)$的最优问题。且这个问题不受g(x,y)所约束，因此可以使用无约束时函数最优问题来解决。至此呼应了开头伸手党结论。]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python版本共存和虚拟环境]]></title>
    <url>%2F2017%2F03%2F12%2F2017-02-python%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[python有很多版本，如何在同一台系统中共存这些版本而且不会冲突，是python开发者一个重要的需求，所以诞生出了Python版本管理器pyenv。另外每个Python项目都会有很多包需要导入，而另一些项目并不需要，如果所有包都加入到系统Python的包目录下的话一方面不好管理另一方面容易出现包的冲突，因此需要为每个项目建立一个虚拟的独立的Python环境就太好了，于是virtualenv和conda工具就出现了。 python 版本2.7.X3.XAnaconda2Anaconda3python有很多版本，如何在同一台系统中共存这些版本而且不会冲突，是python开发者一个重要的需求，所以诞生出了Python版本管理器pyenv。另外每个Python项目都会有很多包需要导入，而另一些项目并不需要，如果所有包都加入到系统Python的包目录下的话一方面不好管理另一方面容易出现包的冲突，因此需要为每个项目建立一个虚拟的独立的Python环境就太好了，于是virtualenv和conda工具就出现了。 pyenvpyenv是一个管理各个python版本的管理器。可以在系统里同时保留多个python版本，等需要时定义需要的版本。 项目地址 安装看项目地址中的readme 使用1pyenv install --list 查看pyenv可安装的版本列表 12pyenv install anaconda2-4.2.0pyenv uninstall x.x.x 安装和卸载指定版本，会将python版本安装在$(pyenv root)/versions/中 1pyenv versions 查看当前已经安装了的python版本。输出内容中，system关键字是系统python版本。 *表示当前环境所处的版本。 1pyenv global anaconda2 全局切换为anaconda科学计算环境(不建议这么做)，做了如果要恢复，则将最后一个参数改为–unset 1pyenv local python3.4.1 当前环境接环。在当前目录以下。如果要恢复，则将最后一个参数改为–unset virtualenv本来这是一个单独的软件用来虚拟一个python版本环境，让每个工作环境都有一套独立的python各自的第三方插件互不影响。然而在 pyenv 下有一个插件 pyenv-virtualenv 他可以在 pyenv 的环境下担负起 virtualenv 的事情。（如果使用的是原生python可以用这个工具，如果用的是anaconda则不用这个，用下一章说的conda工具来完成虚拟环境） 项目地址 安装看项目地址中的readme 使用1pyenv virtualenv 2.7.1 env271 在当前目录下创建一个 python 版本为2.7.1的环境，环境名字为 env271。 这个环境的真实目录位于~/.pyenv/versions/ 1pyenv activate env271 （创建时并不激活）激活当前环境。此时已经进入虚拟环境，在当前环境下所有pip等操作都不会影响系统环境和系统路径。 1pyenv deactivate 离开已激活的环境，切换回系统环境。但并没有被删除，下次依旧可以启动。 1pyenv uninstall env271 删除一个环境，当然也可以到真实目录下删除文件夹。 conda本来不想用这个的，但是因为 pyenv-virtualenv 有一些问题，无法很好的管理conda环境，比如有一些anaconda 自带的一些命令(例如pylint)无法被使用。因此还是老老实实使用 conda 来管理虚拟环境。 安装conda 是自带于 anaconda 的所以并不需要额外安装，如果在 anaconda 环境中就可以使用。conda 不仅可以进行 环境管理，还可以包管理，和对 anaconda和conda 进行版本升级。 使用由于conda使用方法太多，因此这里罗列一些常用的主要是一些虚拟环境的命令。具体的到官网文档去查看一下。 首先conda工具是需要在anaconda环境下的，因此先执行pyenv local anaconda3-4.2.0进入anaconda环境后就可以执行conda工具了。 12conda create --name myflakes python=x.x anacondaconda create --help 创建一个虚拟环境。可以指定名字，指定包，甚至制定python(这样的话就python版本管理了所以不建议使用，python版本管理交给pyenv)，所以命令中 python=x.x 可以不写 12conda info --envsconda env list 罗列已经创建的环境，两条命令是一样的。 12source activate myflakes //Linux,OSXactivate myflakes //Windows 激活一个环境。和virtualenv一样，创建不等于激活。激活后才能真正使用虚拟环境。如果发生错误Error: activate must be sourced. Run &#39;source activate envname&#39;说明activate命令没有找对，导致错误。吧命令改成1source &lt;PATH TO ANACONDA&gt;/anaconda3/bin/activate &lt;ENV NAME&gt; 这样就能成功建立虚拟环境了。 12deactivate myflakessource deactivate myflakes 退出虚拟环境。 1conda remove --name myflakes --all 删除一个虚拟环境。 1conda create --name flowers --clone snowflakes 复制一个虚拟环境。这个是个不错的好功能。 12conda env export &gt; environment.ymlconda env create -f environment.yml conda还能吧环境配置文件导出，在另一台机器上重新读入配置文件，就能复刻你的环境了。 其他使用conda 还能进行包的管理。调用的是 pip 所以也很棒。 123conda listconda list -n myflakesconda search numpy //查询package 查看当前环境已安装包，用-n指定后，就是查看某个环境下的已安装包 123conda install -n myflakes numpyconda update -n myflakes numpyconda remove -n myflakes numpy 为某个指定的环境安装包，升级包，删除包。 123conda update condaconda update anacondaconda update python 它还能升级自身和anaconda和python的版本。 它和pip一样也能设置安装包的镜像位置。其余还有能使用R命令等等，都到官网文档中搜索一下。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_10： Regular Expression Matching]]></title>
    <url>%2F2017%2F02%2F27%2F2017-02leetcode_10_Regular_Expression_Matching%2F</url>
    <content type="text"><![CDATA[leetcode #10 Regular Expression Matching 题目详解, 看网上帖子说的不清楚都是直接给代码也没个例子，所以起个帖子记录下自己的思路。 本文主要讲述递归解法和动态规划解法的思想。 LeetCode_10_Regular Expression Matching原文要求如下： Implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.1234567891011121314151617&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the **entire** input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → trueisMatch(&quot;aaaa&quot;,&quot;ab*a*c*a&quot;) → true #自己加的 解法有两种递归递归想法比较简单代码也比较清楚，但耗时很长复杂度是指数级别考虑递归思想时，只需要考虑终结情况，和当前情况，其他的任由递归完成当前情况的考虑如下：因为*号是最复杂的情况甚至可以发生0次于是分成两种情况分别考虑：p[1] 为 * 和 p[1] 不为 * p[1] != * 时：说明当前p[0]不会发生0-n次的变化直接对比就可以，剩下的交给递归 s[0] == p[0] 判等（这个相等包含了.的情况，后面相同） 递归判断 isMatch(s[1:],p[1:]) 两个子串 p[1] == * 时：说明当前p[0]会发生0-n次的变化，而且都是有效的 假设发生 0次 ：那么直接将p[0,1]跳过进行递归 isMatch(s,p[2:]) 假设发生 1次以上：那么得先判等，然后s+1进行递归 s[0]==p[0] and isMatch(s[1:],p) 好了所有情况都考虑好了，就可以直接上代码了，递归思想还是比较简单，直接看代码可能比看上述文字更加简单直接。 talk is cheep show me code： 1234567891011121314class Solution(object): def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if p=="": return s=="" if len(p)&gt;1 and '*' == p[1]: return self.isMatch(s, p[2:]) or ((s!="" and (s[0]==p[0] or '.'==p[0])) and self.isMatch(s[1:], p)) else: return (s!="" and (s[0]==p[0] or '.'==p[0])) and self.isMatch(s[1:], p[1:]) 动态规划动态规划处理这个问题，更加有效，复杂度为 O(N*M).但是不同于递归直接看代码，动态规划我简直还是先看状态公式更加明了。用dp[i][j]来代表 s[0:i] 与 p[0:j] 是否匹配，初始化 dp[0][0]=1(空串匹配空串) $$dp[i][j]=\begin{cases}dp[i][j-1], &amp; p[j-1]为* 考虑到*只重复1次\\dp[i][j-2], &amp; p[j-1]为* 考虑到*只重复0次\\dp[i-1][j]\;\&amp;\&amp;\;S[i-1]==P[j-2], &amp; p[j-1]为* 考虑到*只重复多次\\dp[i-1][j-1] \;\&amp;\&amp;\; S[i-1]=P[j-1],&amp; p[j-1]不为*\end{cases}$$ 从状态公式基本也能看的明白，要计算 dp[i][j] 的值，要分成两个情况，两个情况分别处理后就能将dp填满，则最后的结果就是 dp[len(s)][len(p)]的值 如果看公式还有点不清楚，来举个栗子：s=&quot;ccd&quot; , p=&quot;a*c*d&quot;dp的矩阵情况如下： # ^ a * c * d ^ 1 0 1 0 1 0 c 0 0 0 1 1 0 c 0 0 0 0 1 0 d 0 0 0 0 0 1 蓝色那个是因为 dp[i][j-1]=1 所以这个*只重复1的匹配结果，因此可以为 1红色那个是因为 dp[i-1][j]=1 &amp;&amp; s[i-1]==p[j-2] 代表已经被重复过了，不止1次，但依然可以被继续重复下去 talk is cheep show me code： 1234567891011121314151617181920212223class Solution(object): def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ lens = len(s) lenp = len(p) dp = [[False for col in range(lenp+1)] for row in range(lens+1)] dp[0][0] = True for j in range(1, lenp+1): dp[0][j] = p[j-1]=='*' and dp[0][j-2]==1 for i in range(1, lens+1): for j in range(1, lenp+1): if p[j-1] == '*': dp[i][j] = dp[i][j-2] or dp[i][j-1] or (dp[i-1][j] and (s[i-1]==p[j-2] or '.'==p[j-2])) else: dp[i][j] = dp[i-1][j-1] and (s[i-1]==p[j-1] or '.'==p[j-1]) return dp[lens][lenp]]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python logging日志模块以及多进程日志]]></title>
    <url>%2F2017%2F02%2F26%2F2017-02-python_logging%2F</url>
    <content type="text"><![CDATA[本篇文章主要对 python logging 的介绍加深理解。更主要是 讨论在多进程环境下如何使用logging 来输出日志， 如何安全地切分日志文件。 本篇文章主要对 python logging 的介绍加深理解。更主要是 讨论在多进程环境下如何使用logging 来输出日志， 如何安全地切分日志文件。 1. logging日志模块介绍python的logging模块提供了灵活的标准模块，使得任何Python程序都可以使用这个第三方模块来实现日志记录。python logging 官方文档 logging框架中主要由四个部分组成： Loggers: 可供程序直接调用的接口 Handlers: 决定将日志记录分配至正确的目的地 Filters: 提供更细粒度的日志是否输出的判断 Formatters: 制定最终记录打印的格式布局 2. logging的组成loggersloggers 就是程序可以直接调用的一个日志接口，可以直接向logger写入日志信息。logger并不是直接实例化使用的，而是通过logging.getLogger(name)来获取对象，事实上logger对象是单例模式，logging是多线程安全的，也就是无论程序中哪里需要打日志获取到的logger对象都是同一个。但是不幸的是logger并不支持多进程，这个在后面的章节再解释，并给出一些解决方案。 【注意】loggers对象是有父子关系的，当没有父logger对象时它的父对象是root，当拥有父对象时父子关系会被修正。举个例子logging.getLogger(&quot;abc.xyz&quot;)会创建两个logger对象，一个是abc父对象，一个是xyz子对象，同时abc没有父对象所以它的父对象是root。但是实际上abc是一个占位对象（虚的日志对象），可以没有handler来处理日志。但是root不是占位对象，如果某一个日志对象打日志时，它的父对象会同时收到日志，所以有些使用者发现创建了一个logger对象时会打两遍日志，就是因为他创建的logger打了一遍日志，同时root对象也打了一遍日志。 每个logger都有一个日志的级别。logging中定义了如下级别 Level Numeric value NOTSET 0 DEBUG 10 INFO 20 WARNING 30 ERROR 40 CRITICAL 50 当一个logger收到日志信息后先判断是否符合level，如果决定要处理就将信息传递给Handlers进行处理。 HandlersHandlers 将logger发过来的信息进行准确地分配，送往正确的地方。举个栗子，送往控制台或者文件或者both或者其他地方(进程管道之类的)。它决定了每个日志的行为，是之后需要配置的重点区域。 每个Handler同样有一个日志级别，一个logger可以拥有多个handler也就是说logger可以根据不同的日志级别将日志传递给不同的handler。当然也可以相同的级别传递给多个handlers这就根据需求来灵活的设置了。 FiltersFilters 提供了更细粒度的判断，来决定日志是否需要打印。原则上handler获得一个日志就必定会根据级别被统一处理，但是如果handler拥有一个Filter可以对日志进行额外的处理和判断。例如Filter能够对来自特定源的日志进行拦截or修改甚至修改其日志级别（修改后再进行级别判断）。 logger和handler都可以安装filter甚至可以安装多个filter串联起来。 FormattersFormatters 指定了最终某条记录打印的格式布局。Formatter会将传递来的信息拼接成一条具体的字符串，默认情况下Format只会将信息%(message)s直接打印出来。Format中有一些自带的LogRecord属性可以使用，如下表格: Attribute Format Description asctime %(asctime)s 将日志的时间构造成可读的形式，默认情况下是‘2016-02-08 12:00:00,123’精确到毫秒 filename %(filename)s 包含path的文件名 funcName %(funcName)s 由哪个function发出的log levelname %(levelname)s 日志的最终等级（被filter修改后的） message %(message)s 日志信息 lineno %(lineno)d 当前日志的行号 pathname %(pathname)s 完整路径 process %(process)s 当前进程 thread %(thread)s 当前线程 一个Handler只能拥有一个Formatter 因此如果要实现多种格式的输出只能用多个Handler来实现。 3. logging 配置简易配置首先在 loggers 章节里说明了一点，我们拥有一个缺省的日志对象root，这个root日志对象的好处是我们直接可以使用logging来进行配置和打日志。例如： 12logging.basicConfig(level=logging.INFO,filename='logger.log')logging.info("info message") 所以这里的简易配置所指的就是root日志对象，随拿随用。每个logger都是单例对象所以配置过一遍之后程序内任何地方调用都可以。我们只需要调用basicConfig就可以对root日志对象进行简易的配置，事实上这种方式相当有效易用。它使得调用任何logger时保证至少一定会有一个Handler能够处理日志。简易配置大致可以这么设置： 12345logging.basicConfig(level=logging.INFO, format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s', datefmt='[%Y-%m_%d %H:%M:%S]', filename='../log/my.log', filemode='a') 代码配置另一种更加细致地设置方式是在代码中配置，但这种设置方式是使用的最少的方式，毕竟谁也不希望把设置写死到代码里面去。但是这里也稍微介绍一下，虽然用的不多，在必要的时候也可以用一把。(以后补上) 配置文件配置python中logging的配置文件是基于ConfigParser的功能。也就是说配置文件的格式也是按照这种方式来编写。先奉上一个比较一般的配置文件再细说 123456789101112131415161718192021222324252627282930313233343536373839##############################################[loggers]keys=root, log02[logger_root]level=INFOhandlers=handler01[logger_log02]level=DEBUGhandler=handler02qualname=log02##############################################[handlers]keys=handler01,handler02[handler_handler01]class=FileHandlerlevel=INFOformatter=form01args=(&apos;../log/cv_parser_gm_server.log&apos;,&quot;a&quot;)[handler_handler02]class=StreamHandlerlevel=NOTSETformatter=form01args=(sys.stdout,)##############################################[formatters]keys=form01,form02[formatter_form01]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(process)d %(message)sdatefmt=[%Y-%m-%d %H:%M:%S][formatter_form02]format=(message)s############################################## 相信看一遍以后，也找出规律了，我将几个大块用#分了出来。每一个logger或者handler或者formatter都有一个key名字。以logger为例，首先需要在[loggers]配置中加上key名字代表了这个logger。然后用[loggers_xxxx]其中xxxx为key名来具体配置这个logger，在log02中我配置了level和一个handler名，当然你可以配置多个hander。根据这个handler名再去 [handlers]里面去找具体handler的配置，以此类推。然后在代码中，这样加载配置文件即可： 1logging.config.fileConfig(log_conf_file) 在handler中有一个class配置，可能有些读者并不是很懂。其实这个是logging里面原先就写好的一些handler类，你可以在这里直接调用。class指向的类相当于具体处理的Handler的执行者。在logging的文档中可以知道这里所有的Handler类都是线程安全的，大家可以放心使用。那么问题就来了，如果多进程怎么办呢。在下一章我主要就是重写Handler类，来实现在多进程环境下使用logging。 我们自己重写或者全部新建一个Handler类，然后将class配置指向自己的Handler类就可以加载自己重写的Handler了。 4. logging遇到多进程（important）这部分其实是我写这篇文章的初衷。python中由于某种历史原因，多线程的性能基本可以无视。所以一般情况下python要实现并行操作或者并行计算的时候都是使用多进程。但是 python 中logging 并不支持多进程，所以会遇到不少麻烦。 本次就以 TimedRotatingFileHandler 这个类的问题作为例子。这个Handler本来的作用是：按天切割日志文件。（当天的文件是xxxx.log 昨天的文件是xxxx.log.2016-06-01）。这样的好处是，一来可以按天来查找日志，二来可以让日志文件不至于非常大, 过期日志也可以按天删除。但是问题来了，如果是用多进程来输出日志，则只有一个进程会切换，其他进程会在原来的文件中继续打，还有可能某些进程切换的时候早就有别的进程在新的日志文件里打入东西了，那么他会无情删掉之，再建立新的日志文件。反正将会很乱很乱，完全没法开心的玩耍。所以这里就想了几个办法来解决多进程logging问题 原因在解决之前，我们先看看为什么会导致这样的原因。先将 TimedRotatingFileHandler 的源代码贴上来，这部分是切换时所作的操作：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def doRollover(self): """ do a rollover; in this case, a date/time stamp is appended to the filename when the rollover happens. However, you want the file to be named for the start of the interval, not the current time. If there is a backup count, then we have to get a list of matching filenames, sort them and remove the one with the oldest suffix. """ if self.stream: self.stream.close() self.stream = None # get the time that this sequence started at and make it a TimeTuple currentTime = int(time.time()) dstNow = time.localtime(currentTime)[-1] t = self.rolloverAt - self.interval if self.utc: timeTuple = time.gmtime(t) else: timeTuple = time.localtime(t) dstThen = timeTuple[-1] if dstNow != dstThen: if dstNow: addend = 3600 else: addend = -3600 timeTuple = time.localtime(t + addend) dfn = self.baseFilename + "." + time.strftime(self.suffix, timeTuple) if os.path.exists(dfn): os.remove(dfn) # Issue 18940: A file may not have been created if delay is True. if os.path.exists(self.baseFilename): os.rename(self.baseFilename, dfn) if self.backupCount &gt; 0: for s in self.getFilesToDelete(): os.remove(s) if not self.delay: self.stream = self._open() newRolloverAt = self.computeRollover(currentTime) while newRolloverAt &lt;= currentTime: newRolloverAt = newRolloverAt + self.interval #If DST changes and midnight or weekly rollover, adjust for this. if (self.when == 'MIDNIGHT' or self.when.startswith('W')) and not self.utc: dstAtRollover = time.localtime(newRolloverAt)[-1] if dstNow != dstAtRollover: if not dstNow: # DST kicks in before next rollover, so we need to deduct an hour addend = -3600 else: # DST bows out before next rollover, so we need to add an hour addend = 3600 newRolloverAt += addend self.rolloverAt = newRolloverAt 我们观察 if os.path.exists(dfn) 这一行开始，这里的逻辑是如果 dfn 这个文件存在，则要先删除掉它，然后将 baseFilename 这个文件重命名为 dfn 文件。然后再重新打开 baseFilename这个文件开始写入东西。那么这里的逻辑就很清楚了 假设当前日志文件名为 current.log 切分后的文件名为 current.log.2016-06-01 判断 current.log.2016-06-01 是否存在，如果存在就删除 将当前的日志文件名 改名为current.log.2016-06-01 重新打开新文件（我观察到源代码中默认是”a” 模式打开，之前据说是”w”） 于是在多进程的情况下，一个进程切换了，其他进程的句柄还在 current.log.2016-06-01 还会继续往里面写东西。又或者一个进程执行切换了，会把之前别的进程重命名的 current.log.2016-06-01 文件直接删除。又或者还有一个情况，当一个进程在写东西，另一个进程已经在切换了，会造成不可预估的情况发生。还有一种情况两个进程同时在切文件，第一个进程正在执行第3步，第二进程刚执行完第2步，然后第一个进程 完成了重命名但还没有新建一个新的 current.log 第二个进程开始重命名，此时第二个进程将会因为找不到 current 发生错误。如果第一个进程已经成功创建了 current.log 第二个进程会将这个空文件另存为 current.log.2016-06-01。那么不仅删除了日志文件，而且，进程一认为已经完成过切分了不会再切，而事实上他的句柄指向的是current.log.2016-06-01。好了这里看上去很复杂，实际上就是因为对于文件操作时，没有对多进程进行一些约束，而导致的问题。那么如何优雅地解决这个问题呢。我提出了两种方案，当然我会在下面提出更多可行的方案供大家尝试。 解决方案1先前我们发现 TimedRotatingFileHandler 中逻辑的缺陷。我们只需要稍微修改一下逻辑即可： 判断切分后的文件 current.log.2016-06-01 是否存在，如果不存在则进行重命名。（如果存在说明有其他进程切过了，我不用切了，换一下句柄即可） 以”a”模式 打开 current.log 发现修改后就这么简单~talking is cheap show me the code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class SafeRotatingFileHandler(TimedRotatingFileHandler): def __init__(self, filename, when='h', interval=1, backupCount=0, encoding=None, delay=False, utc=False): TimedRotatingFileHandler.__init__(self, filename, when, interval, backupCount, encoding, delay, utc) """ Override doRollover lines commanded by "##" is changed by cc """ def doRollover(self): """ do a rollover; in this case, a date/time stamp is appended to the filename when the rollover happens. However, you want the file to be named for the start of the interval, not the current time. If there is a backup count, then we have to get a list of matching filenames, sort them and remove the one with the oldest suffix. Override, 1. if dfn not exist then do rename 2. _open with "a" model """ if self.stream: self.stream.close() self.stream = None # get the time that this sequence started at and make it a TimeTuple currentTime = int(time.time()) dstNow = time.localtime(currentTime)[-1] t = self.rolloverAt - self.interval if self.utc: timeTuple = time.gmtime(t) else: timeTuple = time.localtime(t) dstThen = timeTuple[-1] if dstNow != dstThen: if dstNow: addend = 3600 else: addend = -3600 timeTuple = time.localtime(t + addend) dfn = self.baseFilename + "." + time.strftime(self.suffix, timeTuple)## if os.path.exists(dfn):## os.remove(dfn) # Issue 18940: A file may not have been created if delay is True.## if os.path.exists(self.baseFilename): if not os.path.exists(dfn) and os.path.exists(self.baseFilename): os.rename(self.baseFilename, dfn) if self.backupCount &gt; 0: for s in self.getFilesToDelete(): os.remove(s) if not self.delay: self.mode = "a" self.stream = self._open() newRolloverAt = self.computeRollover(currentTime) while newRolloverAt &lt;= currentTime: newRolloverAt = newRolloverAt + self.interval #If DST changes and midnight or weekly rollover, adjust for this. if (self.when == 'MIDNIGHT' or self.when.startswith('W')) and not self.utc: dstAtRollover = time.localtime(newRolloverAt)[-1] if dstNow != dstAtRollover: if not dstNow: # DST kicks in before next rollover, so we need to deduct an hour addend = -3600 else: # DST bows out before next rollover, so we need to add an hour addend = 3600 newRolloverAt += addend self.rolloverAt = newRolloverAt 不要以为代码那么长，其实修改部分就是 “##” 注释的地方而已，其他都是照抄源代码。这个类继承了 TimedRotatingFileHandler 重写了这个切分的过程。这个解决方案十分优雅，改换的地方非常少，也十分有效。但有网友提出，这里有一处地方依然不完美，就是rename的那一步，如果就是这么巧，同时两个或者多个进程进入了 if 语句，先后开始 rename 那么依然会发生删除掉日志的情况。确实这种情况确实会发生，由于切分文件一天才一次，正好切分的时候同时有两个Handler在操作，又正好同时走到这里，也是蛮巧的，但是为了完美，可以加上一个文件锁，if 之后加锁，得到锁之后再判断一次，再进行rename这种方式就完美了。代码就不贴了，涉及到锁代码，影响美观。 解决方案2我认为最简单有效的解决方案。重写FileHandler类（这个类是所有写入文件的Handler都需要继承的TimedRotatingFileHandler 就是继承的这个类；我们增加一些简单的判断和操作就可以。 我们的逻辑是这样的： 判断当前时间戳是否与指向的文件名是同一个时间 如果不是，则切换 指向的文件即可 结束，是不是很简单的逻辑。 talking is cheap show me the code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class SafeFileHandler(FileHandler): def __init__(self, filename, mode, encoding=None, delay=0): """ Use the specified filename for streamed logging """ if codecs is None: encoding = None FileHandler.__init__(self, filename, mode, encoding, delay) self.mode = mode self.encoding = encoding self.suffix = "%Y-%m-%d" self.suffix_time = "" def emit(self, record): """ Emit a record. Always check time """ try: if self.check_baseFilename(record): self.build_baseFilename() FileHandler.emit(self, record) except (KeyboardInterrupt, SystemExit): raise except: self.handleError(record) def check_baseFilename(self, record): """ Determine if builder should occur. record is not used, as we are just comparing times, but it is needed so the method signatures are the same """ timeTuple = time.localtime() if self.suffix_time != time.strftime(self.suffix, timeTuple) or not os.path.exists(self.baseFilename+'.'+self.suffix_time): return 1 else: return 0 def build_baseFilename(self): """ do builder; in this case, old time stamp is removed from filename and a new time stamp is append to the filename """ if self.stream: self.stream.close() self.stream = None # remove old suffix if self.suffix_time != "": index = self.baseFilename.find("."+self.suffix_time) if index == -1: index = self.baseFilename.rfind(".") self.baseFilename = self.baseFilename[:index] # add new suffix currentTimeTuple = time.localtime() self.suffix_time = time.strftime(self.suffix, currentTimeTuple) self.baseFilename = self.baseFilename + "." + self.suffix_time self.mode = 'a' if not self.delay: self.stream = self._open() check_baseFilename 就是执行逻辑1判断；build_baseFilename 就是执行逻辑2换句柄。就这么简单完成了。这种方案与之前不同的是，当前文件就是 current.log.2016-06-01 ，到了明天当前文件就是current.log.2016-06-02 没有重命名的情况，也没有删除的情况。十分简洁优雅。也能解决多进程的logging问题。 解决方案其他当然还有其他的解决方案，例如由一个logging进程统一打日志，其他进程将所有的日志内容打入logging进程管道由它来打理。还有将日志打入网络socket当中也是同样的道理。 5. 参考资料python logging 官方文档林中小灯的切分方案，方案一就是从这儿来的]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test Markdown]]></title>
    <url>%2F2017%2F02%2F22%2F2017-02-Test_Markdown%2F</url>
    <content type="text"><![CDATA[列举一些常用的 markdown 语法, 作为测试以及备忘。 You can write regular markdown here and Jekyll will automatically convert it to a nice webpage. I strongly encourage you to take 5 minutes to learn how to write in markdown - it’ll teach you how to transform regular text into bold/italics/headings/tables/etc. Markdown 语法手册 1. 分级标题使用 === 表示一级标题，使用 — 表示二级标题你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3一般来说都是使用 #号 来使用, 注意 #号 需要顶格写示例： 12345这是一个一级标题===这是一个二级标题----### 这是一个三级标题 2. 斜体和粗体使用 *和 ** 表示斜体和粗体 示例： 这是*斜体* 这是**粗体** 这是斜体 这是粗体 这是斜体 这是粗体 3. 链接使用 [描述](链接地址) 为文字增加链接 示例： 这是去往[本人博客](http://doudou0o.github.com/blog) 的链接 这是去往 本人博客 的链接 4. 插入图像使用 ![描述](图片链接) 插入图像(好像插入时保持原图片大小)和链接比较类似,唯一的区别就是前面有一个!在Hexo 中本地图片使用 ![本地图片](/img/a.jpg) 示例：在线图片![图片](https://assets-cdn.github.com/images/modules/logos_page/Octocat.png) 本地图片![本地图片](./start.jpg) 大小控制图片1&#123;% img full-image /2017/02/22/Test_Markdown/start.jpg 200 200 %&#125; 5. 文字引用使用 &gt; 表示文字引用同 #号 一样需要定格写否则没有效果而且上下需要有空格 示例： 你好我是引用文档 6. 无序列表使用 *，+，- 表示无序列表都是需要顶格写且前后得有空行 示例： 无序列表项 一 无序列表项 二 无序列表项 三 7. 有序列表使用数字和点表示有序列表。例: 1. xxxx 注意要有一个空格! 示例： 有序列表项 一 有序列表项 二 有序列表项 三 8. 行内代码块使用 `代码` 表示行内代码块好像在行内代码块中不会高亮 示例：此行内有一个行内代码块java vs cpp 9. 代码块代码块使用 ``` python(或者~~~)balabala``` 包裹起来而且可以加上所用的语言,也可以不加另外由于 Pygments 或 Rouge 的使用,可以用 包裹更加好看(不要加行号! 不然会超级难看) def show @widget = Widget(params[:id]) respond_to do |format| format.html # show.html.erb format.json { render json: @widget } end end 10. 表格 Number Next number Previous number Five Six Four Ten Eleven Nine Seven Eight Six Two Three One 11. Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表并且支持子列表嵌套以及混用Markdown语法，示例： - [ ] **买菜** - [ ] 小排 - [x] 鸡肉 - [ ] 番茄 - [x] 辣椒 - [x] 小辣椒 - [x] 红辣椒 生成 这样一个 Todo 列表： [ ] 买菜 [ ] 小排 [x] 鸡肉 [ ] 番茄 [x] 辣椒 [x] 小辣椒 [x] 红辣椒 12. 注脚使用 [^keyword] 表示注脚 这是一个注脚[^footnote]的样例 13. 页内链接(hexo下暂时无效没找到正确的姿势)1234567先在某处设定一个锚点`&lt;a id=&quot;jump&quot; name=&quot;jump&quot;&gt;锚点&lt;/a&gt;`类似这样然后使用 `\[结论\](\#jump) `这样的方法就可以在页内跳转或者在标题后面跟上ID也可以同样跳转`### 标题 &#123;#ID&#125;`示例: [示例1](#jump) [示例2](#ID2) [^footnote]: 这是一个 注脚]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 搭建博客]]></title>
    <url>%2F2017%2F02%2F20%2F2017-02-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[倒腾了很久 Jekyll 之后，还是决定投入到 Hexo 阵营中来。Hexo的 markdown 编译器以及优秀的各种模板还有一键部署都是相当赞的功能。由于我也是新手白菜，记录本篇搭建日志，以防遗忘和换些功能或模板设置。 github 部分略过Hexo什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo 的文档还是比较简单明白的~这里是Hexo中文文档(https://hexo.io/zh-cn/docs/)这里是Hexo英文文档(https://hexo.io/docs/index.html) 安装 Hexo首先安装前，确认已经成功安装了 Node.js 和 git Node.js Git 然后目录下执行(windows 也是一样) 12$ npm install -g hexo-cli --save$ npm install --save #(忘了这步也没事，就是安装些插件之类的) 建立博客进入你要搭建博客的目录，执行以下命令，就能新建一些博客文件12$ cd &lt;folder&gt;$ hexo init 新建完成后，指定文件夹的目录如下：123456789.|├── _config.yml #配置文件├── package.json #应用程序的信息（其实我也不知道）├── scaffolds #模版文件夹├── source #资源文件夹| ├── _drafts #草稿| └── _posts #发布的文章└── themes #主题 Hexo 命令init1$ hexo init 新建一直网站，注意了，这里它会新建模板文件，新建一个HelloWorld.md，新建一个_config.yml。其他不变，所以轻易没备份这些内容钱不要敲这个命令 clean 、new 、 server123$ hexo clean #清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。$ hexo new &lt;file1&gt; #新建一篇文章$ hexo server #启动服务器 generate 、 deploy12$ hexo generate #生成静态文件$ hexo deploy #部署网站 在部署前，在 _config.yml 中将自己的deploy设置配置好部署时发现 ERROR Deployer not found: git 则需要安装这个插件1npm install hexo-deployer-git --save 博客设置找几个自己喜欢的主题，根据主题的设置来进行配置。整个 Hexo 博客有两个 config 一个是 Hexo 的设置，另一个就是 主题下的 config基本上每个主题会有一定配置教程，注意其中的路径问题。 博客写作本地图片首先将 Hexo _config.yml 配置中将这个打开 post_asset_folder:true打开后，每次新建一篇文章会同时建立一个同名的文件夹，里面的资源可以直接访问如果没有找到，那么可能是插件未安装，执行以下命令1npm install https://github.com/CodeFalling/hexo-asset-image --save 于是在markdown中可以直接引用改资源，如下1![本地图片](./a.jpg) 本地预览一般情况下，直接修改，刷新页面就可以看见修改，不需要重启服务。但是有时候，必须要重启服务，而且先 clean 再 server 才能生效。 其他遇到问题再写其他]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F12%2F22%2F2016-12-hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
